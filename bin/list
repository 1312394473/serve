#!/usr/bin/env node
var regeneratorRuntime = require('babel-regenerator-runtime')

import micro, { send } from 'micro-core'
import { red, green } from 'chalk'
import fs from 'fs'
import minimist from 'minimist'
import pkg from '../../package.json'
import path from 'path'
import { compile } from 'handlebars'
import { isBinarySync } from 'istextorbinary'
import { StringDecoder } from 'string_decoder'
import filesize from 'filesize'
import { version } from '../../package'

const argv = minimist(process.argv.slice(2))

if (argv.help || argv.h) {
  console.log(`
list [options]

  -p | --port [number]     port to listen on
  -v | --version           show version
  -h | --help              show help
`)
  process.exit(0)
}

if (argv.v || argv.version) {
  console.log(version)
  process.exit(0)
}

const port = argv.port || argv.p
const directory = argv._.pop()

process.env.ASSET_DIR = '/' + Math.random().toString(36).substr(2, 10)

let current = process.cwd()

if (directory) {
  current = path.resolve(process.cwd(), directory)
}

const isDir = dir => {
  try {
    fs.statSync(dir)
  } catch (err) {
    return false
  }

  if (fs.statSync(dir).isDirectory()) {
    return true
  }

  return false
}

const exists = file => {
  try {
    fs.statSync(file)
  } catch (err) {
    return false
  }

  return true
}

if (!isDir(current)) {
  console.error(red('Specified directory doesn\'t exist!'))
  process.exit(1)
}

const prepareView = () => {
  let viewContent = false
  const viewPath = path.normalize(__dirname + '/../../views/index.hbs')

  try {
    viewContent = fs.readFileSync(viewPath, 'utf8')
  } catch (err) {
    throw err
  }

  return compile(viewContent)
}

const ignoredFiles = [
  '.DS_Store'
]

const renderDirectory = dir => {
  let files = []
  const subPath = path.relative(current, dir)

  try {
    files = fs.readdirSync(dir)
  } catch (err) {
    throw err
  }

  for (let file of files) {
    let filePath = path.resolve(dir, file)
    let index = files.indexOf(file)
    let details = path.parse(filePath)

    details.ext = details.ext.split('.')[1]
    details.relative = path.join(subPath, details.base)

    if (isDir(filePath)) {
      details.base = details.base + '/'
    } else {
      let fileStats

      try {
        fileStats = fs.statSync(filePath)
      } catch (err) {
        throw err
      }

      details.size = filesize(fileStats.size, { round: 0 })
    }

    if (ignoredFiles.indexOf(details.base) > -1) {
      delete files[index]
    } else {
      files[files.indexOf(file)] = details
    }
  }

  if (dir.indexOf(current + '/') > -1) {
    files.unshift({
      base: '..',
      relative: '..'
    })
  }

  const render = prepareView(),
        directory = path.join(path.basename(current), subPath, '/'),
        pathParts = directory.split('/')

  let paths = []
  pathParts.pop()

  for (let part in pathParts) {
    let before = 0,
        parents = []

    while (before <= part) {
      parents.push(pathParts[before])
      before++
    }

    parents.shift()

    paths.push({
      name: pathParts[part],
      url: '/' + parents.join('/')
    })
  }

  const details = {
    port,
    files,
    assetDir: process.env.ASSET_DIR,
    directory,
    nodeVersion: process.version.split('v')[1],
    paths
  }

  return render(details)
}

const server = micro(async (req, res) => {
  let related = path.parse(path.join(current, req.url))

  if (related.dir.indexOf(process.env.ASSET_DIR) > -1) {
    const relative = path.relative(process.env.ASSET_DIR, req.url)
    related = path.parse(path.join(__dirname, '/../assets', relative))
  }

  related = path.format(related)

  if (!exists(related)) {
    return send(res, 404, 'Not found')
  }

  if (isDir(related)) {
    const indexPath = path.join(related, '/index.html')

    if (!exists(indexPath)) {
      return send(res, 200, renderDirectory(related))
    }

    let indexContent

    try {
      indexContent = fs.readFileSync(indexPath, 'utf8')
    } catch (err) {
      throw err
    }

    res.setHeader('Content-Type', 'text/html')
    return send(res, 200, indexContent)
  }

  let body = 'Not able to load file!'

  try {
    body = fs.readFileSync(related)
  } catch (err) {
    throw err
  }

  const isBinary = isBinarySync(path.parse(related).base, body)

  if (isBinary) {
    res.writeHead(200)
    res.write(body, 'binary')
    res.end(null, 'binary')
  } else {
    const decoder = new StringDecoder('utf8')
    send(res, 200, decoder.write(body))
  }
})

server.listen(port, () => {
  const details = server.address()

  if (!process.env.NOW) {
    console.log(green(`Running on http://localhost:${details.port}`))
  }
})
