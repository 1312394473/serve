#!/usr/bin/env node

import { default as micro, send } from 'micro'
import { red, green } from 'chalk'
import fs from 'fs'
import bin from 'commander'
import pkg from '../../package.json'
import path from 'path'
import { compile } from 'handlebars'
import { isBinarySync } from 'istextorbinary'
import { StringDecoder } from 'string_decoder'

bin
  .version(pkg.version)
  .option('-p, --port [int]', 'The port on which micro will be running')
  .parse(process.argv)

process.env.ASSET_DIR = '/' + Math.random().toString(36).substr(2, 10)

const directory = bin.args[bin.args.length - 1]
let current = process.cwd()

if (directory) {
  current = path.resolve(process.cwd(), directory)
}

const isDir = dir => {
  try {
    fs.statSync(dir)
  } catch (err) {
    return false
  }

  if (fs.statSync(dir).isDirectory()) {
    return true
  }

  return false
}

const exists = file => {
  try {
    fs.statSync(file)
  } catch (err) {
    return false
  }

  return true
}

if (!isDir(current)) {
  console.error(red('Specified directory doesn\'t exist!'))
  process.exit(1)
}

const prepareView = () => {
  let viewContent = false
  const viewPath = path.normalize(__dirname + '/../../views/index.hbs')

  try {
    viewContent = fs.readFileSync(viewPath, 'utf8')
  } catch (err) {
    throw err
  }

  return compile(viewContent)
}

const ignoredFiles = [
  '.DS_Store'
]

const renderDirectory = dir => {
  let files = []

  try {
    files = fs.readdirSync(dir)
  } catch (err) {
    throw err
  }

  for (let file of files) {
    let filePath = path.resolve(current, file)
    let index = files.indexOf(file)
    let details = path.parse(filePath)

    details.ext = details.ext.split('.')[1]

    if (ignoredFiles.includes(details.base)) {
      delete files[index]
    } else {
      files[files.indexOf(file)] = details
    }
  }

  const render = prepareView()

  const details = {
    files,
    assetDir: process.env.ASSET_DIR,
    directory: path.parse(current).base + '/',
    port: 3000,
    nodeVersion: process.version.split('v')[1]
  }

  return render(details)
}

const server = micro(async (req, res) => {
  let related = path.parse(path.join(current, req.url))

  if (related.dir.includes(process.env.ASSET_DIR)) {
    const relative = path.relative(process.env.ASSET_DIR, req.url)
    related = path.parse(path.join(__dirname, '/../assets', relative))
  }

  related = path.format(related)

  if (!exists(related)) {
    return send(res, 404, 'Not found')
  }

  if (isDir(related)) {
    return send(res, 200, renderDirectory(related))
  }

  let body = 'Not able to load file!'

  try {
    body = fs.readFileSync(related)
  } catch (err) {
    throw err
  }

  const isBinary = isBinarySync(path.parse(related).base, body)

  if (isBinary) {
    res.writeHead(200)
    res.write(body, 'binary')
    res.end(null, 'binary')
  } else {
    const decoder = new StringDecoder('utf8')
    send(res, 200, decoder.write(body))
  }
})

server.listen(3000, () => {
  const details = server.address()
  console.log(green(`Running on http://localhost:${details.port}`))
})
